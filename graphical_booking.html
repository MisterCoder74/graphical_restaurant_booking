<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Visualizzatore Layout Ristorante</title>
<style>
body {
font-family: Arial, sans-serif;
margin: 0;
padding: 20px;
background-color: #f0f0f0;
}
.container {
max-width: 1200px;
margin: 0 auto;
background: white;
border-radius: 8px;
overflow: hidden;
box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}
.header {
background: #2c3e50;
color: white;
padding: 15px 20px;
}
.controls {
padding: 15px 20px;
background: #ecf0f1;
border-bottom: 1px solid #bdc3c7;
}
.controls button {
margin-right: 10px;
padding: 8px 15px;
background: #3498db;
color: white;
border: none;
border-radius: 4px;
cursor: pointer;
}
.controls button:hover {
background: #2980b9;
}
.controls button:disabled {
background: #bdc3c7;
cursor: not-allowed;
}
.controls button.success {
background: #27ae60;
}
.controls button.success:hover:not(:disabled) {
background: #229954;
}
.controls button.warning {
background: #f39c12;
}
.controls button.warning:hover:not(:disabled) {
background: #e67e22;
}
.canvas-container {
display: flex;
position: relative;
overflow: auto;
}
#canvas {
border: 1px solid #bdc3c7;
cursor: default;
display: block;
}
#selectedTableInfoPanel {
display: none;
border: 1px solid #bdc3c7;
width: 300px;
min-height: 200px;
border-radius: 8px;
padding: 15px;
background: #f8f9fa;
margin-left: 20px;
max-height: 500px;
overflow-y: auto;
}
.info {
padding: 10px 20px;
background: #f8f9fa;
border-top: 1px solid #bdc3c7;
font-size: 14px;
color: #666;
}
.selected-info {
background: #d4edda;
border: 1px solid #c3e6cb;
border-radius: 4px;
padding: 8px;
margin-top: 10px;
display: none;
}
.status-message {
margin-top: 10px;
padding: 8px;
border-radius: 4px;
display: none;
}
.status-success {
background: #d4edda;
border: 1px solid #c3e6cb;
color: #155724;
}
.status-error {
background: #f8d7da;
border: 1px solid #f5c6cb;
color: #721c24;
}
.status-loading {
background: #fff3cd;
border: 1px solid #ffeaa7;
color: #856404;
}
        
.status-message.status-info {
    background-color: #3498db;
    color: white;
    border-left: 4px solid #2980b9;
}        

/* Modal Styles */
.modal {
display: none;
position: fixed;
z-index: 1000;
left: 0;
top: 0;
width: 100%;
height: 100%;
background-color: rgba(0,0,0,0.4);
}
.modal-content {
background-color: #fefefe;
margin: 5% auto;
padding: 20px;
border: none;
border-radius: 8px;
width: 90%;
max-width: 500px;
box-shadow: 0 4px 20px rgba(0,0,0,0.3);
}
.modal-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 20px;
padding-bottom: 10px;
border-bottom: 1px solid #eee;
}
.close {
color: #aaa;
font-size: 28px;
font-weight: bold;
cursor: pointer;
}
.close:hover,
.close:focus {
color: #000;
text-decoration: none;
}
.form-group {
margin-bottom: 15px;
}
.form-group label {
display: block;
margin-bottom: 5px;
font-weight: bold;
color: #333;
}
.form-group input, .form-group select {
width: 100%;
padding: 8px 12px;
border: 1px solid #ddd;
border-radius: 4px;
font-size: 14px;
box-sizing: border-box;
}
.form-group input:focus, .form-group select:focus {
border-color: #3498db;
outline: none;
box-shadow: 0 0 5px rgba(52, 152, 219, 0.3);
}
.modal-buttons {
text-align: right;
margin-top: 20px;
}
.modal-buttons button {
margin-left: 10px;
padding: 8px 16px;
border: none;
border-radius: 4px;
cursor: pointer;
font-size: 14px;
}
.btn-primary {
background-color: #3498db;
color: white;
}
.btn-primary:hover {
background-color: #2980b9;
}
.btn-secondary {
background-color: #95a5a6;
color: white;
}
.btn-secondary:hover {
background-color: #7f8c8d;
}
.table-info {
background: #f8f9fa;
padding: 15px;
border-radius: 4px;
margin-bottom: 20px;
border: 1px solid #e9ecef;
}
.table-info h3 {
margin-top: 0;
color: #2c3e50;
}

/* Legenda colori */
.legend {
margin-top: 10px;
padding: 10px;
background: #f8f9fa;
border-radius: 4px;
display: flex;
flex-wrap: wrap;
gap: 15px;
font-size: 12px;
}
.legend-item {
display: flex;
align-items: center;
gap: 5px;
}
.legend-color {
width: 20px;
height: 15px;
border-radius: 3px;
border: 1px solid #ccc;
}

/* Auto-update status */
.auto-update-status {
background: #e8f4fd;
border: 1px solid #bee5eb;
border-radius: 4px;
padding: 6px 10px;
margin-top: 5px;
font-size: 12px;
color: #0c5460;
}
</style>
</head>
<body>
<div class="container">
<div class="header">
<h1>Prenotazione Grafica</h1>
<a style="padding: 8px 12px; margin: 6px 0; border-radius: 8px; background: blue; color: white; text-decoration: none; cursor: pointer;" href="dashboard.html">Torna alla Dashboard</a>        
</div>
<div class="controls">
<button onclick="loadLayout()" class="success" id="loadBtn">Aggiorna Layout</button>

<div class="selected-info" id="selectedInfo">
<strong>Tavolo selezionato:</strong> <span id="selectedTableInfo"></span>
<button onclick="viewSelectedTableInfo()" style="margin-left: 10px; padding: 4px 8px;">Info e Storico</button>
<button onclick="showBookingModal()" style="margin-left: 5px; padding: 4px 8px; background: #27ae60;">Assegna Prenotazione</button>
<button onclick="freeTable()" style="margin-left: 5px; padding: 4px 8px; background: #e74c3c;">Libera Tavolo</button>
</div>
<div class="status-message" id="statusMessage"></div>

</div>
<div class="canvas-container">
<canvas id="canvas" width="800" height="500"></canvas>
<div id="selectedTableInfoPanel">
<h2>Informazioni Tavolo</h2>
</div>
</div>
<div class="info">
<strong>Istruzioni:</strong>
‚Ä¢ Clicca su un tavolo per selezionarlo e visualizzarne le informazioni
‚Ä¢ Usa "Assegna Prenotazione" per prenotare un tavolo
‚Ä¢ Usa "Libera Tavolo" per rendere disponibile un tavolo occupato
‚Ä¢ L'auto-aggiornamento controlla automaticamente le prenotazioni ogni minuto
<div class="legend">
<div class="legend-item">
<div class="legend-color" style="background: #8e44ad;"></div>
<span>Disponibile</span>
</div>
<div class="legend-item">
<div class="legend-color" style="background: #f39c12;"></div>
<span>Prenotato</span>
</div>
<div class="legend-item">
<div class="legend-color" style="background: #e74c3c;"></div>
<span>Occupato</span>
</div>
</div>
</div>
</div>

<!-- Modal per prenotazioni -->
<div id="bookingModal" class="modal">
<div class="modal-content">
<div class="modal-header">
<h2>Assegna Prenotazione</h2>
<span class="close" onclick="closeBookingModal()">&times;</span>
</div>
<div class="table-info" id="modalTableInfo">
<!-- Informazioni tavolo verranno inserite qui -->
</div>
<form id="bookingForm">
<div class="form-group">
<label for="bookingName">Cognome:</label>
<input type="text" id="bookingName" name="cognome" required>
</div>
<div class="form-group">
<label for="bookingDate">Data:</label>
<input type="date" id="bookingDate" name="data" required>
</div>
<div class="form-group">
<label for="bookingTime">Ora:</label>
<input type="time" id="bookingTime" name="ora" required>
</div>
<div class="form-group">
<label for="bookingPersons">Numero Persone:</label>
<input type="number" id="bookingPersons" name="persone" min="1" required>
</div>
<div class="modal-buttons">
<button type="button" class="btn-secondary" onclick="closeBookingModal()">Annulla</button>
<button type="submit" class="btn-primary">Conferma Prenotazione</button>
</div>
</form>
</div>
</div>

<script>
// Variabili globali
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let tables = [];
let selectedTable = null;
let isLoading = false;
        
let autoUpdateTimer = null;
let autoUpdateEnabled = true;
let lastAutoUpdateTime = null;        

// Classe Table
class Table {
constructor(x, y, name, seats, orientation='horizontal', currentStatus='disponibile', history=[]) {
this.x = x;
this.y = y;
this.name = name;
this.seats = seats;
this.orientation = orientation;
this.width = this.calculateWidth();
this.height = this.calculateHeight();
this.id = Date.now() + Math.random();
this.currentStatus = currentStatus || 'disponibile';
this.history = history || [];
}

calculateWidth() {
if (this.orientation === 'vertical') {
return Math.max(50, 40);
} else {
return Math.max(60, this.seats * 8 + 20);
}
}

calculateHeight() {
if (this.orientation === 'vertical') {
return Math.max(60, this.seats * 8 + 20);
} else {
return Math.max(50, 40);
}
}

draw() {
const isSelected = (selectedTable === this);

// Ombra
ctx.fillStyle = 'rgba(0,0,0,0.1)';
ctx.fillRect(this.x + 2, this.y + 2, this.width, this.height);

// Colore di sfondo basato su stato
let fillColor, strokeColor;
switch(this.currentStatus) {
case 'occupato':
fillColor = isSelected ? '#c0392b' : '#e74c3c'; // Rosso
strokeColor = isSelected ? '#2c3e50' : '#a93226';
break;
case 'prenotato':
fillColor = isSelected ? '#d68910' : '#f39c12'; // Arancione
strokeColor = isSelected ? '#2c3e50' : '#b7704c';
break;
default: // disponibile
fillColor = isSelected ? '#3498db' : '#8e44ad'; // Viola
strokeColor = isSelected ? '#2c3e50' : '#7d3c98';
}

ctx.fillStyle = fillColor;
ctx.fillRect(this.x, this.y, this.width, this.height);

// Bordo
ctx.strokeStyle = strokeColor;
ctx.lineWidth = 2;
ctx.strokeRect(this.x, this.y, this.width, this.height);

// Testo
ctx.fillStyle = 'white';
ctx.font = 'bold 12px Arial';
ctx.textAlign = 'center';
if (this.orientation==='vertical') {
ctx.save();
ctx.translate(this.x + this.width/2, this.y + this.height/2);
ctx.rotate(-Math.PI/2);
ctx.fillText(this.name, 0, -5);
ctx.font='10px Arial';
ctx.fillText(`${this.seats} posti`, 0, 8);
ctx.restore();
} else {
ctx.fillText(this.name, this.x + this.width/2, this.y + this.height/2 - 5);
ctx.font='10px Arial';
ctx.fillText(`${this.seats} posti`, this.x + this.width/2, this.y + this.height/2 + 8);
}
}

contains(x,y) {
return x>=this.x && x<=this.x+this.width && y>=this.y && y<=this.y+this.height;
}
}

// Funzioni di utilit√†
function setLoadingState(loading) {
isLoading = loading;
document.getElementById('loadBtn').disabled = loading;
}

function showStatus(msg, type='success') {
const el = document.getElementById('statusMessage');
el.textContent = msg;
el.className = `status-message status-${type}`;
el.style.display = 'block';
if (type !== 'loading') {
setTimeout(() => el.style.display = 'none', 3000);
}
}

function hideStatus() {
document.getElementById('statusMessage').style.display = 'none';
}

// Disegno griglia e canvas
function drawGrid() {
ctx.strokeStyle = '#ecf0f1';
ctx.lineWidth = 1;
for (let x = 0; x < canvas.width; x += 20) {
ctx.beginPath();
ctx.moveTo(x, 0);
ctx.lineTo(x, canvas.height);
ctx.stroke();
}
for (let y = 0; y < canvas.height; y += 20) {
ctx.beginPath();
ctx.moveTo(0, y);
ctx.lineTo(canvas.width, y);
ctx.stroke();
}
}

function drawCanvas() {
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = '#ffffff';
ctx.fillRect(0, 0, canvas.width, canvas.height);
drawGrid();
tables.forEach(t => t.draw());
}

// Posizione mouse
function getMousePos(e) {
const rect = canvas.getBoundingClientRect();
return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

function findTableAt(x, y) {
for (let i = tables.length - 1; i >= 0; i--) {
if (tables[i].contains(x, y)) return tables[i];
}
return null;
}

// Selezione tavolo
function selectTable(t) {
selectedTable = t;
updateSelectedInfo();
drawCanvas();
}

// Funzione helper per ottenere il testo dello stato in italiano
function getStatusText(status) {
switch(status) {
case 'occupato': return 'OCCUPATO';
case 'prenotato': return 'PRENOTATO';
case 'disponibile': return 'DISPONIBILE';
default: return 'SCONOSCIUTO';
}
}

function updateSelectedInfo() {
const info = document.getElementById('selectedInfo');
const infoText = document.getElementById('selectedTableInfo');
if (selectedTable) {
const orientText = selectedTable.orientation === 'horizontal' ? 'Orizzontale' : 'Verticale';
const statusText = getStatusText(selectedTable.currentStatus);
infoText.textContent = `${selectedTable.name} (${selectedTable.seats} posti - ${orientText} - ${statusText})`;
info.style.display = 'block';
} else {
info.style.display = 'none';
}
}


function viewSelectedTableInfo() {
const panel = document.getElementById('selectedTableInfoPanel');
if (!selectedTable) {
panel.style.display = 'none';
return;
}

const t = selectedTable;
let historyHtml = '';

if (t.history && t.history.length > 0) {
    const now = new Date();
    let hasVisibleItems = false;
    
    historyHtml = '<h4>Storico Prenotazioni e Operazioni:</h4><ul style="max-height: 200px; overflow-y: auto;">';
    
    t.history.forEach((item, index) => {
        let shouldShow = true;
        
        // Per le prenotazioni, controlla se sono future
        if (item.type === 'prenotazione' || (item.cognome && item.data && item.ora)) {
            if (item.data && item.ora) {
                try {
                    // Crea l'oggetto Date dalla data e ora della prenotazione
                    const bookingDateTime = new Date(`${item.data}T${item.ora}`);
                    
                    // Mostra solo se la prenotazione √® nel futuro
                    shouldShow = bookingDateTime > now;
                } catch (e) {
                    // Se c'√® un errore nel parsing della data, mostra comunque l'item
                    console.warn('Errore nel parsing della data prenotazione:', item.data, item.ora);
                    shouldShow = true;
                }
            }
        }
        
        if (shouldShow) {
            hasVisibleItems = true;
            
            if (typeof item === 'string') {
                historyHtml += `<li>${item}</li>`;
            } else if (item.type === 'aggiornamento_automatico') {
                historyHtml += `<li><em>üîÑ Aggiornamento automatico: ${item.old_status} ‚Üí ${item.new_status}</em> <small>(${new Date(item.timestamp).toLocaleString()})</small></li>`;
            } else if (item.type === 'liberazione') {
                historyHtml += `<li>üîì <strong>Tavolo liberato</strong> <small>(${new Date(item.timestamp).toLocaleString()})</small></li>`;
            } else if (item.type === 'cancellazione_prenotazione') {
                historyHtml += `<li>‚ùå <strong>Prenotazione cancellata</strong> - ${item.cognome} <small>(${new Date(item.timestamp).toLocaleString()})</small></li>`;
            } else if (item.type === 'prenotazione' || (item.cognome && item.data && item.ora)) {
                const bookingDateTime = new Date(`${item.data}T${item.ora}`);
                const timeUntil = Math.round((bookingDateTime - now) / (1000 * 60 * 60)); // ore fino alla prenotazione
                
                let timeInfo = '';
                if (timeUntil > 24) {
                    const days = Math.floor(timeUntil / 24);
                    timeInfo = ` - tra ${days} giorni`;
                } else if (timeUntil > 0) {
                    timeInfo = ` - tra ${timeUntil} ore`;
                } else {
                    timeInfo = ' - oggi';
                }
                
                historyHtml += `<li>üìù <strong>Prenotazione futura:</strong> ${item.cognome || 'N/A'} - ${item.data || 'N/A'} ${item.ora || 'N/A'} - ${item.persone || 'N/A'} persone${timeInfo} <small>(creata: ${item.timestamp ? new Date(item.timestamp).toLocaleString() : 'N/A'})</small></li>`;
            } else {
                // Fallback per entry non riconosciute
                historyHtml += `<li>üìã Operazione generica <small>(${item.timestamp ? new Date(item.timestamp).toLocaleString() : 'N/A'})</small></li>`;
            }
        }
    });
    
    historyHtml += '</ul>';
    
    // Se non ci sono elementi visibili, mostra un messaggio appropriato
    if (!hasVisibleItems) {
        historyHtml = '<h4>Storico Prenotazioni e Operazioni:</h4><p><em>Nessuna prenotazione futura o operazione recente</em></p>';
    }
} else {
    historyHtml = '<p><em>Nessuna operazione nello storico</em></p>';
}

let statusColor;
switch(t.currentStatus) {
case 'occupato': statusColor = '#e74c3c'; break;
case 'prenotato': statusColor = '#f39c12'; break;
default: statusColor = '#27ae60';
}

panel.innerHTML = `
<h2>Informazioni Tavolo</h2>
<p><strong>Nome:</strong> ${t.name}</p>
<p><strong>Posti:</strong> ${t.seats}</p>
<p><strong>Orientamento:</strong> ${t.orientation}</p>
<p><strong>Posizione X:</strong> ${Math.round(t.x)}</p>
<p><strong>Posizione Y:</strong> ${Math.round(t.y)}</p>
<p><strong>Larghezza:</strong> ${Math.round(t.width)}</p>
<p><strong>Altezza:</strong> ${Math.round(t.height)}</p>
<p><strong>Status attuale:</strong> <span style="color: ${statusColor}; font-weight: bold;">${getStatusText(t.currentStatus)}</span></p>
${historyHtml}
`;
panel.style.display = 'block';
}

// Carica layout
async function loadLayout() {
if (isLoading) return;
setLoadingState(true);
showStatus('Caricamento layout in corso...', 'loading');

try {
const response = await fetch('load_layout.php', {
method: 'GET',
headers: {'Cache-Control': 'no-store'}
});

const result = await response.json();
if (result.success && result.data && result.data.tables) {
tables = result.data.tables.map(td => new Table(
td.x,
td.y,
td.name,
td.seats,
td.orientation || 'horizontal',
td.currentStatus || 'disponibile',
td.history || []
));

selectedTable = null;
updateSelectedInfo();
drawCanvas();
showStatus('Layout caricato con successo!', 'success');
} else {
throw new Error(result.error || 'Errore nel caricamento del layout');
}
} catch(e) {
showStatus('Errore nel caricamento: ' + e.message, 'error');
console.error(e);
}
setLoadingState(false);
}

// Modal per prenotazioni
function showBookingModal() {
if (!selectedTable || isLoading) return;

const modal = document.getElementById('bookingModal');
const modalTableInfo = document.getElementById('modalTableInfo');
const bookingPersons = document.getElementById('bookingPersons');

// Aggiorna info tavolo nel modal
modalTableInfo.innerHTML = `
<h3>Tavolo: ${selectedTable.name}</h3>
<p><strong>Stato:</strong> ${getStatusText(selectedTable.currentStatus)}</p>
<p><strong>Capacit√†:</strong> ${selectedTable.seats} posti</p>
`;

// Imposta il massimo numero di persone
bookingPersons.max = selectedTable.seats;

// Imposta data odierna come default
const today = new Date().toISOString().split('T')[0];
document.getElementById('bookingDate').value = today;

// Reset form
document.getElementById('bookingForm').reset();
document.getElementById('bookingDate').value = today;

modal.style.display = 'block';
}

function closeBookingModal() {
document.getElementById('bookingModal').style.display = 'none';
}

// Gestione form prenotazione
document.getElementById('bookingForm').addEventListener('submit', async function(e) {
e.preventDefault();
if (!selectedTable || isLoading) return;

const formData = new FormData(this);
const bookingData = {
tableName: selectedTable.name,
cognome: formData.get('cognome'),
data: formData.get('data'),
ora: formData.get('ora'),
persone: parseInt(formData.get('persone')),
timestamp: new Date().toISOString()
};

// Validazione
if (bookingData.persone > selectedTable.seats) {
alert(`Il numero di persone (${bookingData.persone}) supera la capacit√† del tavolo (${selectedTable.seats})`);
return;
}

setLoadingState(true);
showStatus('Salvando prenotazione...', 'loading');

try {
const response = await fetch('save_booking.php', {
method: 'POST',
headers: {
'Content-Type': 'application/json',
'Cache-Control': 'no-store'
},
body: JSON.stringify(bookingData)
});

const result = await response.json();
if (result.success) {
// Aggiorna il tavolo locale con il nuovo status ricevuto dal server
selectedTable.currentStatus = result.tableStatus || 'prenotato';
selectedTable.history = selectedTable.history || [];
selectedTable.history.push(`Prenotazione: ${bookingData.cognome} - ${bookingData.data} ${bookingData.ora} - ${bookingData.persone} persone (${new Date().toLocaleString()})`);

updateSelectedInfo();
drawCanvas();
viewSelectedTableInfo();
closeBookingModal();
showStatus('Prenotazione salvata con successo!', 'success');
} else {
throw new Error(result.error || 'Errore nel salvataggio della prenotazione');
}
} catch(e) {
showStatus('Errore nel salvataggio: ' + e.message, 'error');
}
setLoadingState(false);
});

// Libera tavolo
async function freeTable() {
if (!selectedTable || isLoading) return;

if (!confirm(`Sei sicuro di voler liberare il tavolo ${selectedTable.name}?`)) {
return;
}

setLoadingState(true);
showStatus('Liberando tavolo...', 'loading');

try {
const response = await fetch('free_table.php', {
method: 'POST',
headers: {
'Content-Type': 'application/json',
'Cache-Control': 'no-store'
},
body: JSON.stringify({tableName: selectedTable.name})
});

const result = await response.json();
if (result.success) {
// Aggiorna il tavolo locale
selectedTable.currentStatus = 'disponibile';
selectedTable.history = selectedTable.history || [];
selectedTable.history.push(`Tavolo liberato - ${new Date().toLocaleString()}`);
updateSelectedInfo();
drawCanvas();
viewSelectedTableInfo();
showStatus('Tavolo liberato con successo!', 'success');
} else {
throw new Error(result.error || 'Errore nella liberazione del tavolo');
}
} catch(e) {
showStatus('Errore nella liberazione: ' + e.message, 'error');
}
setLoadingState(false);
}
        
async function performAutoUpdate() {
    if (!autoUpdateEnabled || isLoading) {
        console.log('Auto-aggiornamento saltato (disabilitato o caricamento in corso)');
        return;
    }

    try {
        console.log('üîÑ Esecuzione auto-aggiornamento...');
        
        const response = await fetch('update_table_status.php', {
            method: 'GET',
            headers: {'Cache-Control': 'no-store'}
        });

        const result = await response.json();
        
        if (result.success) {
            lastAutoUpdateTime = new Date();
            
            // Se ci sono stati aggiornamenti, ricarica il layout
            if (result.updatedTables > 0) {
                console.log(`‚úÖ Auto-aggiornamento completato: ${result.updatedTables} tavoli aggiornati`);
                await loadLayoutSilently(); // Carica senza mostrare messaggi di stato
                
                // Mostra un messaggio discreto solo se ci sono stati cambiamenti significativi
                if (result.updatedTables > 0) {
                    showStatus(`üîÑ ${result.updatedTables} tavoli aggiornati automaticamente`, 'info');
                }
            } else {
                console.log('‚úÖ Auto-aggiornamento completato: nessun cambiamento');
            }
        } else {
            console.warn('‚ö†Ô∏è Errore auto-aggiornamento:', result.error);
        }
    } catch (e) {
        console.error('‚ùå Errore durante auto-aggiornamento:', e);
    }
}

// Versione silenziosa del caricamento layout (senza messaggi di stato)
async function loadLayoutSilently() {
    try {
        const response = await fetch('load_layout.php', {
            method: 'GET',
            headers: {'Cache-Control': 'no-store'}
        });

        const result = await response.json();
        if (result.success && result.data && result.data.tables) {
            const oldSelectedTableName = selectedTable ? selectedTable.name : null;
            
            tables = result.data.tables.map(td => new Table(
                td.x,
                td.y,
                td.name,
                td.seats,
                td.orientation || 'horizontal',
                td.currentStatus || 'disponibile',
                td.history || []
            ));

            // Mantieni la selezione del tavolo se esisteva
            if (oldSelectedTableName) {
                selectedTable = tables.find(t => t.name === oldSelectedTableName) || null;
            }

            updateSelectedInfo();
            drawCanvas();
            
            // Aggiorna il pannello info se era aperto
            if (selectedTable && document.getElementById('selectedTableInfoPanel').style.display === 'block') {
                viewSelectedTableInfo();
            }
        }
    } catch(e) {
        console.error('Errore nel caricamento silenzioso:', e);
    }
}

// Funzione per avviare l'auto-aggiornamento
function startAutoUpdate() {
    if (autoUpdateTimer) {
        clearInterval(autoUpdateTimer);
    }
    
    console.log('üöÄ Avvio auto-aggiornamento (ogni 60 secondi)');
    
    // Esegui il primo aggiornamento dopo 10 secondi per dare tempo al caricamento iniziale
    setTimeout(performAutoUpdate, 10000);
    
    // Poi continua ogni 60 secondi
    autoUpdateTimer = setInterval(performAutoUpdate, 60000);
}

// Funzione per fermare l'auto-aggiornamento
function stopAutoUpdate() {
    if (autoUpdateTimer) {
        clearInterval(autoUpdateTimer);
        autoUpdateTimer = null;
        console.log('‚èπÔ∏è Auto-aggiornamento fermato');
    }
}

// Funzione per abilitare/disabilitare l'auto-aggiornamento
function toggleAutoUpdate() {
    autoUpdateEnabled = !autoUpdateEnabled;
    console.log(`üîÑ Auto-aggiornamento ${autoUpdateEnabled ? 'abilitato' : 'disabilitato'}`);
    
    if (autoUpdateEnabled && !autoUpdateTimer) {
        startAutoUpdate();
    } else if (!autoUpdateEnabled) {
        stopAutoUpdate();
    }
}

// Aggiungi un nuovo tipo di messaggio di stato per l'info
function showStatus(msg, type='success') {
    const el = document.getElementById('statusMessage');
    el.textContent = msg;
    el.className = `status-message status-${type}`;
    el.style.display = 'block';
    
    // Per i messaggi info, usa un timeout pi√π breve
    const timeout = type === 'info' ? 2000 : (type !== 'loading' ? 3000 : 0);
    if (timeout > 0) {
        setTimeout(() => el.style.display = 'none', timeout);
    }
}

// Modifica la funzione loadLayout esistente per essere pi√π robusta
async function loadLayout() {
    if (isLoading) return;
    setLoadingState(true);
    showStatus('Caricamento layout in corso...', 'loading');

    try {
        await loadLayoutSilently();
        showStatus('Layout caricato con successo!', 'success');
    } catch(e) {
        showStatus('Errore nel caricamento: ' + e.message, 'error');
        console.error(e);
    }
    setLoadingState(false);
}

// Gestione della visibilit√† della pagina per ottimizzare le risorse
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        console.log('üì± Pagina nascosta - pausa auto-aggiornamento');
        stopAutoUpdate();
    } else {
        console.log('üì± Pagina visibile - riprendi auto-aggiornamento');
        if (autoUpdateEnabled) {
            startAutoUpdate();
            // Esegui un aggiornamento immediato quando la pagina torna visibile
            setTimeout(performAutoUpdate, 1000);
        }
    }
});

// Gestione beforeunload per pulizia
window.addEventListener('beforeunload', () => {
    stopAutoUpdate();
});

        
        
canvas.addEventListener('click', e => {
if (isLoading) return;
const pos = getMousePos(e);
const t = findTableAt(pos.x, pos.y);
if (t) {
selectTable(t);
} else {
selectedTable = null;
updateSelectedInfo();
drawCanvas();
}
});        


window.addEventListener('load', () => {
    drawCanvas();
    loadLayout().then(() => {
        // Avvia l'auto-aggiornamento solo dopo che il layout iniziale √® stato caricato
        if (autoUpdateEnabled) {
            startAutoUpdate();
        }
    });
});
</script>
</body>
</html>